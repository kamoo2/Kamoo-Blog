---
title: Priority Queue ğŸ”¥
description: ìš°ì„ ìˆœìœ„ íì— ëŒ€í•´ì„œ ì•Œì•„ë³´ê³  Javascriptë¥¼ ì´ìš©í•´ ì§ì ‘ êµ¬í˜„í•´ë³´ì
tags:
  - Algorithm
createdAt: 2023-10-31 20:20:00
---

## Priority Queue
Priority QueueëŠ” ë°ì´í„°ë¥¼ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬ëœ ìƒíƒœë¡œ ì €ì¥í•˜ëŠ” ìë£Œêµ¬ì¡° ì…ë‹ˆë‹¤.

ì¼ë°˜ íë‚˜ ìŠ¤íƒê³¼ëŠ” ë‹¬ë¦¬, ë°ì´í„°ì˜ ì¶”ê°€ë‚˜ ì‚­ì œê°€ ì•„ë‹ˆë¼ `ìš°ì„ ìˆœìœ„`ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

ì£¼ë¡œ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

<hr/>

### êµ¬í˜„ ë°©ë²•
Priority QueueëŠ” `2ê°€ì§€ ë°©ë²•`ìœ¼ë¡œ êµ¬í˜„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`ì²« ë²ˆì§¸` ë°°ì—´
ë°°ì—´ë¡œ ë§Œë“¤ ìˆ˜ ìˆì§€ë§Œ ì‹œê°„ë³µì¡ë„ê°€ O(n)ìœ¼ë¡œ íš¨ìœ¨ì„±ì´ ë–¨ì–´ì§‘ë‹ˆë‹¤.

`ë‘ ë²ˆì§¸` Heap
ì¶”ê°€ì™€ ì‚­ì œê°€ O(log n) ì´ë¯€ë¡œ íš¨ìœ¨ì„±ì´ ì¢‹ì•„ ì£¼ë¡œ `Heap`ìœ¼ë¡œ êµ¬í˜„ë©ë‹ˆë‹¤.

ìš°ì„ ìˆœìœ„ íì—ì„œ ì‚½ì…ê³¼ ì‚­ì œëŠ” ì™„ì „ ì´ì§„ íŠ¸ë¦¬ì¸ `Heap`ì—ì„œì˜ ì‚½ì…, ì‚­ì œì™€ ë™ì¼í•œ ë™ì‘ ì›ë¦¬ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
ë” ìì„¸íˆ ì•Œì•„ë³´ê³  ì‹¶ë‹¤ë©´ `Heap` í¬ìŠ¤íŠ¸ë¥¼ ë³´ê³  ì™€ì£¼ì„¸ìš” ğŸ˜†

<hr/>

### Javascriptë¡œ êµ¬í˜„í•´ë³´ê¸°
ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì‚¬ìš©í•  PriorityQueueë¥¼ ë§Œë“¤ì–´ ë´…ì‹œë‹¤.
ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì´ë¯€ë¡œ `ìµœì†Œí™`ìœ¼ë¡œ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

> ë¨¼ì € PQì— ì €ì¥ ë  ë°ì´í„°ì¸ Node í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ ë´…ì‹œë‹¤.

```javascript
class Node {
  constructor(value,priority){
    this.value = value;
    this.priority = priority;
  }
}
```

> ë‹¤ìŒì€ Priority Queue í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê¸° ì „ì— í•„ìš”í•œ í•„ë“œì™€ ë©”ì„œë“œë¥¼ ì •ë¦¬í•´ë´…ì‹œë‹¤.

#### í•„ë“œ
- heap : Node ì¸ìŠ¤í„´ìŠ¤ ê°ì²´ë“¤ì„ ì €ì¥í•  ê³µê°„

#### ë©”ì„œë“œ
- getLeftChildIndex(parentIndex) : ë¶€ëª¨ ì¸ë±ìŠ¤ë¡œ ì™¼ìª½ ìì‹ì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
- getRightChildIndex(parentIndex) : ë¶€ëª¨ ì¸ë±ìŠ¤ë¡œ ì˜¤ë¥¸ìª½ ìì‹ì˜ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
- getParentIndex(childIndex) : ìì‹ ì¸ë±ìŠ¤ë¡œ ë¶€ëª¨ ì¸ë±ìŠ¤ë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ
- swap(idx1,idx2) : heapì—ì„œ idx1ê³¼ idx2ì— ìˆëŠ” ë°ì´í„°ë¥¼ êµí™˜í•˜ëŠ” ë©”ì„œë“œ
- enqueue(value,priority) : heapì— Nodeë¥¼ ì‚½ì…í•˜ëŠ” ë©”ì„œë“œ
- dequeue() : 0ë²ˆì§¸ indexì˜ ë…¸ë“œë¥¼ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ

> ì´ì œ Priority Queue í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•´ë´…ì‹œë‹¤ ğŸ”¥

```javascript
class PriorityQueue {
  constructor() {
    this.heap = [];
  }

  getLeftChildIndex = (parentIndex) => parentIndex * 2 + 1;

  getRightChildIndex = (parentIndex) => parentIndex * 2 + 2;

  getParentIndex = (childIndex) => Math.floor((childIndex-1) /2);

  swap = (idx1,idx2) => {
    [this.heap[idx1],this.heap[idx2]] = [this.heap[idx2],this.heap[idx1]];
  }

  enqueue = (value,priority) => {
    const node = new Node(value,priority);
    this.heap.push(node);

    let index = this.heap.length -1;

    // ìµœì†Œí™ ì •ë ¬
    while(index > 0){
      const parentIndex = getParentIndex(index);
      if(this.heap[parentIndex].priority < this.heap[index].priority) break; // ìµœì†Œí™ ì •ë ¬ ì™„ë£Œ
      this.swap(parentIndex,index);
      index = parentIndex;
    }
  }

  dequeue = () => {
    if(this.heap.length === 0) return null;

    let min = this.heap[0];
    let end = this.heap.pop();

    if(this.heap.length > 0){
      // ìµœì†Œí™ ì •ë ¬
      this.heap[0] = end;

      let index = 0;

      while(true){
        const leftChildIndex = this.getLeftChildIndex(index);
        const rightChildIndex = this.getRightChildIndex(index);
        let swapIdx = null;

        if(leftChildIndex < this.heap.length &&
            this.heap[leftChildIndex].priority < this.heap[index].priority){
          swapIdx = leftChildIndex;
        }

        if(rightChildIndex < this.heap.length &&
            this.heap[rightChildIndex].priority < (swapIdx === null ? this.heap[index].priority : this.heap[leftChildIndex].priority)){
            swapIdx = rightChildIndex;
        }

        if(swapIdx === null) break;

        this.swap(index,swapIdx);
        index = swapIdx;
      }
    }
    return min;
  }
}
```

<hr/>

### Priority Queue í´ë˜ìŠ¤ Refactoring

ë§Œë“¤ê³  ë‚˜ë‹ˆ ì•„ì‰¬ìš´ ì ì´ ìˆì–´ì„œ ë¦¬íŒ©í† ë§ í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤.
enqueueì™€ dequeue ë©”ì„œë“œëŠ” ë‹¨ì§€ heapì— ë°ì´í„°ë¥¼ ë„£ê³  ë¹¼ëŠ”ê²Œ ì£¼ ëª©ì ì´ê¸° ë•Œë¬¸ì— ìµœì†Œí™ì— ë§ê²Œ ì¬ì •ë ¬í•˜ëŠ” ë¡œì§ì„ ë”°ë¡œ ë¹¼ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.
ì™¸ë¶€ì—ì„œëŠ” `enqueue` `dequeue` `heap`ì—ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ ë‚˜ë¨¸ì§€ ë©”ì„œë“œì—ëŠ” `#`ì„ ë¶™ì—¬ `private`ë¡œ ë³€ê²½í•˜ë ¤ê³  í–ˆìœ¼ë‚˜, ë°±ì¤€ì—ì„œëŠ” `#`ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!

```javascript
class PriorityQueue {
  constructor(){
    this.heap = [];
  }

  getLeftChildIndex = (parentIndex) => parentIndex * 2 + 1;

  getRightChildIndex = (parentIndex) => parentIndex * 2 + 2;

  getParentIndex = (childIndex) => Math.floor((childIndex-1) /2);

  swap = (idx1,idx2) => {
    [this.heap[idx1],this.heap[idx2]] = [this.heap[idx2],this.heap[idx1]];
  }

  heapifyUp = () => {
    let index = this.heap.length -1;
    while(index > 0){
      let parentIndex = this.getParentIndex(index);
      if(this.heap[index].priority > this.heap[parentIndex].priority)break;
      this.swap(index,parentIndex);
      index = parentIndex;
    }
  }

  heapifyDown = () => {
    let index = 0;
    while(true){
      const leftChildIndex = this.getLeftChildIndex(index);
      const rightChildIndex = this.getRightChildIndex(index);
      let swapIdx = null;

      // ì™¼ìª½ ìì‹ ë…¸ë“œì™€ ë¹„êµ
      if(leftChildIndex < this.heap.length &&
          this.heap[leftChildIndex].priority < this.heap[index].priority){
        swapIdx = leftChildIndex;
      }

      // ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œì™€ ë¹„êµ
      if(rightChildIndex < this.heap.length &&
          this.heap[rightChildIndex].priority < (swapIdx === null ? this.heap[index].priority : this.heap[leftChildIndex].priority)){
        swapIdx = rightChildIndex;
      }

      if(swapIdx === null) break;

      this.swap(index,swapIdx);
      index = swapIdx;
    }
  }

  enqueue = (value, priority) => {
    const node = new Node(value,priority);
    this.heap.push(node);
    heapifyUp();
  }

  dequeue = () => {
    if(this.heap.length === 0)return null;
    const min = this.heap[0];
    const end = this.heap.pop();

    if(this.heap.length > 0){
      this.heap[0] = end;
      this.heapifyDown();
    }
    return min;
  }
}
```